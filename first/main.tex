\documentclass[12pt, a4paper, oneside]{memoir}
\input{../preamble.tex}

\title{Теория формальных языков и трансляций. Домашняя работа №1}
\author{Кубышкин Е.А., группа 21.Б-07}
\date{12 сентября 2023г.}

\begin{document}

\maketitle

\section*{Упражнение \romannumeralCaps 1-1.1}
\begin{solution}
    {Функция $K(i, j) = \frac{(i+j-1)(i+j-2)}{2} + j.$}
    {Обратные функции $J(k), I(k)$ такие, что $J(K(i,j)) = j$ и $I(K(i, j)) = i$.}
    {Напишем код на языке Pascal.}
    Функция $\mathrm{DiagNumberAndStart}$ проходит по всем диагоналям, начиная с первой, и фиксирует наибольшее значение, доступное на ней. Возвращает она номер диагонали и число с которого диагональ начинается, так как эту информацию удобно использовать.

    Мы знаем, что $j$~--- это сдвиг числа по диагонали. Таким образом, зная начальное значение диагонали, и значение $K(i,j)$, можем высчитать $j$ по формуле $j = \mathrm{diagStart} - K(i,j) + 1$.

    Так же знаем, что $i + j = \mathrm{diagNum} + 1$, так что можем выразить $i = \mathrm{diagNum} + 1 - j$. В программе $j$ высчитывается напрямую, без использования функции $J(k)$ ради производительности.
    \newpage
    \lstinputlisting{func.pas}
\end{solution}
\section*{Упражнение \romannumeralCaps 1-1.2}
\begin{solution}
    {Функция $\hat K(w, x, y) = K (w, K(x, y))$, где
        \begin{equation*}
            K(x, y) = \frac{(x+y-1)(x+y - 2)}{2} + y.
        \end{equation*}}
    {Тройка чисел $w, x, y$ такая, что $\hat K (w, x, y) = 1000$.}
    {Пользуясь результатами предыдущего упражнения, получим ответ программно.}
    Следуя определению функций $\hat K, I, J$ получаем, что $w = I(1000), x = I(J(1000)), y = J(J(1000))$. Посчитаем значения этих функций: $w = 36, x = 1, y = 4$.
\end{solution}
\section*{Упражнение \romannumeralCaps 1-1.3}
\begin{solution}
    {Рекурсивный язык $L$.}
    {Процедура для перенумерации предложений языка $L$.}
    {Предъявим описание процедуры}
    Описание процедуры:

    \begin{enumerate}
        \item Пусть $i$~--– счетчик, изначально равный $1$
        \item Рассматриваем все предложения из множества $V^*$ и проверяем каждое из них с помощью распознающего алгоритма на принадлежность $L$
        \item Если предложение принадлежит $L$, то назначаем ему номер $i$, увеличиваем $i$ на единицу, рассматриваем следующее предложение из $V^*$
        \item Если предложение не принадлежит $L$, то рассматриваем следующее предложение из $V^*$
    \end{enumerate}
\end{solution}
\section*{Упражнение \romannumeralCaps 1-1.4}
\begin{solution}
    {Процедура, перечисляющая множество целых в монотонном порядке.}
    {Доказать, что это множество рекурсивно, т.е. существует алгоритм определения, находится ли данное целое в этом множестве.}
    {Воспользуемся тем, что процедура порождает элементы множества в монотонном порядке и предъявим описание искомого алгоритма.}
    Описание алгоритма (пусть процедура порождает числа в возрастающем
    порядке):
    \begin{enumerate}
        \item Пусть $N$~--– число, принадлежность которого к множеству мы хотим проверить
        \item Порождаем очередное число $M$ с помощью процедуры, если же все числа множества порождены, завершаем алгоритм с отрицательным ответом
        \item Если $N = M$, то $N$ лежит в множестве, и алгоритм завершается с  положительным ответом
        \item Если $M > N$, то в силу монотонности порождаемых чисел никакое следующее из них уже не совпадет с $N$, и поэтому алгоритм завершается с отрицательным ответом
        \item Если  $M < N$, то возвращаемся к шагу 2)
    \end{enumerate}
    Алгоритм завершится, поскольку в случае конечного множества будет перебрано не больше элементов, чем его мощность, а в любом бесконечном множестве целых рано или поздно найдется число, большее $N$.
\end{solution}
\section*{Упражнение \romannumeralCaps 1-1.5}
\begin{solution}
    {Конечное множество $S$.}
    {Показать, что $S$ рекурсивно (найти алгоритм определения, находится ли некоторый элемент a в этом множестве).}
    {Предъявим описание алгоритма.}
    Составим полный список элементов (аналогично тому, как может быть представлен конечный язык). Алгоритм будет сравнивать элемент $a$ со всеми элементами списка по порядку, и в случае совпадения завершится и вернет положительный ответ. Так как множество $S$ конечно, если $a$ не содержится в $S$, все элементы списка будут проверены, и, когда это произойдет, алгоритм завершится с отрицательным ответом.

\end{solution}
\end{document}